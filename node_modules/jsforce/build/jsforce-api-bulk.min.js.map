{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","jsforce-api-bulk.min.js","lib/api/bulk.js","node_modules/browserify/node_modules/process/browser.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","jsforce","modules","api","Bulk","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","process","inherits","stream","Duplex","events","_","joinStreams","RecordStream","Promise","HttpApi","Job","bulk","type","operation","options","jobId","_bulk","id","state","_batches","EventEmitter","prototype","info","callback","_jobInfo","check","thenCall","open","_logger","toLowerCase","body","extIdField","concurrencyMode","assignmentRuleId","join","_request","method","path","headers","Content-Type","responseType","then","res","emit","jobInfo","err","createBatch","batch","Batch","on","batchId","logger","_waitAssign","debug","object","resolve","list","batchInfoList","batchInfo","isArray","close","_changeState","abort","job","super_","objectMode","_deferred","defer","_setupDataStreams","Writable","converterOptions","nullValue","_uploadStream","Serializable","_uploadDataStream","_downloadStream","Parsable","_downloadDataStream","end","once","pipe","_createRequestStream","dataStream","_dataStream","_write","data","enc","cb","write","read","push","_read","size","chunk","record","clone","Id","attributes","run","exec","execute","input","_result","rdeferred","promise","reject","isObject","isFunction","forEach","isString","onResolved","onReject","onProgress","nextTick","poll","interval","timeout","startTime","Date","getTime","now","name","parseInt","numberRecordsProcessed","retrieve","stateMessage","setTimeout","results","_conn","result","map","ret","success","Success","errors","fail","resultId","resultStream","resultDataStream","BulkApi","apply","arguments","beforeSend","request","accessToken","isSessionExpired","response","statusCode","test","hasErrorInResponseBody","error","parseError","errorCode","exceptionCode","message","exceptionMessage","conn","pollInterval","pollTimeout","baseUrl","instanceUrl","version","url","load","constructor","Object","createJob","cleanup","cleanupOnError","query","soql","m","replace","match","recordStream","streams","_process","2","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","cachedSetTimeout","len","cachedClearTimeout","Item","fun","array","noop","clearTimeout","args","Array","title","browser","env","argv","versions","addListener","off","removeListener","removeAllListeners","binding","cwd","chdir","dir","umask"],"mappings":"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","file":"jsforce-api-bulk.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g=(g.jsforce||(g.jsforce = {}));g=(g.modules||(g.modules = {}));g=(g.api||(g.api = {}));g.Bulk = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (process){\n/*global process*/\n/**\n * @file Manages Salesforce Bulk API related operations\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n'use strict';\n\nvar inherits     = window.jsforce.require('inherits'),\n    stream       = window.jsforce.require('readable-stream'),\n    Duplex       = stream.Duplex,\n    events       = window.jsforce.require('events'),\n    _            = window.jsforce.require('lodash/core'),\n    joinStreams  = window.jsforce.require('multistream'),\n    jsforce      = window.jsforce.require('./core'),\n    RecordStream = window.jsforce.require('./record-stream'),\n    Promise      = window.jsforce.require('./promise'),\n    HttpApi      = window.jsforce.require('./http-api');\n\n/*--------------------------------------------*/\n\n/**\n * Class for Bulk API Job\n *\n * @protected\n * @class Bulk~Job\n * @extends events.EventEmitter\n *\n * @param {Bulk} bulk - Bulk API object\n * @param {String} [type] - SObject type\n * @param {String} [operation] - Bulk load operation ('insert', 'update', 'upsert', 'delete', or 'hardDelete')\n * @param {Object} [options] - Options for bulk loading operation\n * @param {String} [options.extIdField] - External ID field name (used when upsert operation).\n * @param {String} [options.concurrencyMode] - 'Serial' or 'Parallel'. Defaults to Parallel.\n * @param {String} [jobId] - Job ID (if already available)\n */\nvar Job = function(bulk, type, operation, options, jobId) {\n  this._bulk = bulk;\n  this.type = type;\n  this.operation = operation;\n  this.options = options || {};\n  this.id = jobId;\n  this.state = this.id ? 'Open' : 'Unknown';\n  this._batches = {};\n};\n\ninherits(Job, events.EventEmitter);\n\n/**\n * @typedef {Object} Bulk~JobInfo\n * @prop {String} id - Job ID\n * @prop {String} object - Object type name\n * @prop {String} operation - Operation type of the job\n * @prop {String} state - Job status\n */\n\n/**\n * Return latest jobInfo from cache\n *\n * @method Bulk~Job#open\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.info = function(callback) {\n  var self = this;\n  // if cache is not available, check the latest\n  if (!this._jobInfo) {\n    this._jobInfo = this.check();\n  }\n  return this._jobInfo.thenCall(callback);\n};\n\n/**\n * Open new job and get jobinfo\n *\n * @method Bulk~Job#open\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.open = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n\n  // if not requested opening job\n  if (!this._jobInfo) {\n    var operation = this.operation.toLowerCase();\n    if (operation === 'harddelete') { operation = 'hardDelete'; }\n    var body = [\n      '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\n      '<jobInfo  xmlns=\"http://www.force.com/2009/06/asyncapi/dataload\">',\n        '<operation>' + operation + '</operation>',\n        '<object>' + this.type + '</object>',\n        (this.options.extIdField ?\n         '<externalIdFieldName>'+this.options.extIdField+'</externalIdFieldName>' :\n         ''),\n        (this.options.concurrencyMode ?\n         '<concurrencyMode>'+this.options.concurrencyMode+'</concurrencyMode>' :\n         ''),\n        (this.options.assignmentRuleId ?\n          '<assignmentRuleId>' + this.options.assignmentRuleId + '</assignmentRuleId>' :\n          ''),\n        '<contentType>CSV</contentType>',\n      '</jobInfo>'\n    ].join('');\n\n    this._jobInfo = bulk._request({\n      method : 'POST',\n      path : \"/job\",\n      body : body,\n      headers : {\n        \"Content-Type\" : \"application/xml; charset=utf-8\"\n      },\n      responseType: \"application/xml\"\n    }).then(function(res) {\n      self.emit(\"open\", res.jobInfo);\n      self.id = res.jobInfo.id;\n      self.state = res.jobInfo.state;\n      return res.jobInfo;\n    }, function(err) {\n      self.emit(\"error\", err);\n      throw err;\n    });\n  }\n  return this._jobInfo.thenCall(callback);\n};\n\n/**\n * Create a new batch instance in the job\n *\n * @method Bulk~Job#createBatch\n * @returns {Bulk~Batch}\n */\nJob.prototype.createBatch = function() {\n  var batch = new Batch(this);\n  var self = this;\n  batch.on('queue', function() {\n    self._batches[batch.id] = batch;\n  });\n  return batch;\n};\n\n/**\n * Get a batch instance specified by given batch ID\n *\n * @method Bulk~Job#batch\n * @param {String} batchId - Batch ID\n * @returns {Bulk~Batch}\n */\nJob.prototype.batch = function(batchId) {\n  var batch = this._batches[batchId];\n  if (!batch) {\n    batch = new Batch(this, batchId);\n    this._batches[batchId] = batch;\n  }\n  return batch;\n};\n\n/**\n * Check the latest job status from server\n *\n * @method Bulk~Job#check\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.check = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n\n  this._jobInfo = this._waitAssign().then(function() {\n    return bulk._request({\n      method : 'GET',\n      path : \"/job/\" + self.id,\n      responseType: \"application/xml\"\n    });\n  }).then(function(res) {\n    logger.debug(res.jobInfo);\n    self.id = res.jobInfo.id;\n    self.type = res.jobInfo.object;\n    self.operation = res.jobInfo.operation;\n    self.state = res.jobInfo.state;\n    return res.jobInfo;\n  });\n  return this._jobInfo.thenCall(callback);\n};\n\n/**\n * Wait till the job is assigned to server\n *\n * @method Bulk~Job#info\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype._waitAssign = function(callback) {\n  return (this.id ? Promise.resolve({ id: this.id }) : this.open()).thenCall(callback);\n};\n\n\n/**\n * List all registered batch info in job\n *\n * @method Bulk~Job#list\n * @param {Callback.<Array.<Bulk~BatchInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<Bulk~BatchInfo>>}\n */\nJob.prototype.list = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n\n  return this._waitAssign().then(function() {\n    return bulk._request({\n      method : 'GET',\n      path : \"/job/\" + self.id + \"/batch\",\n      responseType: \"application/xml\"\n    });\n  }).then(function(res) {\n    logger.debug(res.batchInfoList.batchInfo);\n    var batchInfoList = res.batchInfoList;\n    batchInfoList = _.isArray(batchInfoList.batchInfo) ? batchInfoList.batchInfo : [ batchInfoList.batchInfo ];\n    return batchInfoList;\n  }).thenCall(callback);\n\n};\n\n/**\n * Close opened job\n *\n * @method Bulk~Job#close\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.close = function() {\n  var self = this;\n  return this._changeState(\"Closed\").then(function(jobInfo) {\n    self.id = null;\n    self.emit(\"close\", jobInfo);\n    return jobInfo;\n  }, function(err) {\n    self.emit(\"error\", err);\n    throw err;\n  });\n};\n\n/**\n * Set the status to abort\n *\n * @method Bulk~Job#abort\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.abort = function() {\n  var self = this;\n  return this._changeState(\"Aborted\").then(function(jobInfo) {\n    self.id = null;\n    self.emit(\"abort\", jobInfo);\n    return jobInfo;\n  }, function(err) {\n    self.emit(\"error\", err);\n    throw err;\n  });\n};\n\n/**\n * @private\n */\nJob.prototype._changeState = function(state, callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n\n  this._jobInfo = this._waitAssign().then(function() {\n    var body = [\n      '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\n      '<jobInfo xmlns=\"http://www.force.com/2009/06/asyncapi/dataload\">',\n        '<state>' + state + '</state>',\n      '</jobInfo>'\n    ].join('');\n    return bulk._request({\n      method : 'POST',\n      path : \"/job/\" + self.id,\n      body : body,\n      headers : {\n        \"Content-Type\" : \"application/xml; charset=utf-8\"\n      },\n      responseType: \"application/xml\"\n    });\n  }).then(function(res) {\n    logger.debug(res.jobInfo);\n    self.state = res.jobInfo.state;\n    return res.jobInfo;\n  });\n  return this._jobInfo.thenCall(callback);\n\n};\n\n\n/*--------------------------------------------*/\n\n/**\n * Batch (extends RecordStream)\n *\n * @protected\n * @class Bulk~Batch\n * @extends {stream.Writable}\n * @implements {Promise.<Array.<RecordResult>>}\n * @param {Bulk~Job} job - Bulk job object\n * @param {String} [batchId] - Batch ID (if already available)\n */\nvar Batch = function(job, batchId) {\n  Batch.super_.call(this, { objectMode: true });\n  this.job = job;\n  this.id = batchId;\n  this._bulk = job._bulk;\n  this._deferred = Promise.defer();\n  this._setupDataStreams();\n};\n\ninherits(Batch, stream.Writable);\n\n\n/**\n * @private\n */\nBatch.prototype._setupDataStreams = function() {\n  var batch = this;\n  var converterOptions = { nullValue : '#N/A' };\n  this._uploadStream = new RecordStream.Serializable();\n  this._uploadDataStream = this._uploadStream.stream('csv', converterOptions);\n  this._downloadStream = new RecordStream.Parsable();\n  this._downloadDataStream = this._downloadStream.stream('csv', converterOptions);\n\n  this.on('finish', function() {\n    batch._uploadStream.end();\n  });\n  this._uploadDataStream.once('readable', function() {\n    batch.job.open().then(function() {\n      // pipe upload data to batch API request stream\n      batch._uploadDataStream.pipe(batch._createRequestStream());\n    });\n  });\n\n  // duplex data stream, opened access to API programmers by Batch#stream()\n  var dataStream = this._dataStream = new Duplex();\n  dataStream._write = function(data, enc, cb) {\n    batch._uploadDataStream.write(data, enc, cb);\n  };\n  dataStream.on('finish', function() {\n    batch._uploadDataStream.end();\n  });\n\n  this._downloadDataStream.on('readable', function() {\n    dataStream.read(0);\n  });\n  this._downloadDataStream.on('end', function() {\n    dataStream.push(null);\n  });\n  dataStream._read = function(size) {\n    var chunk;\n    while ((chunk = batch._downloadDataStream.read()) !== null) {\n      dataStream.push(chunk);\n    }\n  };\n};\n\n/**\n * Connect batch API and create stream instance of request/response\n *\n * @private\n * @returns {stream.Duplex}\n */\nBatch.prototype._createRequestStream = function() {\n  var batch = this;\n  var bulk = batch._bulk;\n  var logger = bulk._logger;\n\n  return bulk._request({\n    method : 'POST',\n    path : \"/job/\" + batch.job.id + \"/batch\",\n    headers: {\n      \"Content-Type\": \"text/csv\"\n    },\n    responseType: \"application/xml\"\n  }, function(err, res) {\n    if (err) {\n      batch.emit('error', err);\n    } else {\n      logger.debug(res.batchInfo);\n      batch.id = res.batchInfo.id;\n      batch.emit('queue', res.batchInfo);\n    }\n  }).stream();\n};\n\n/**\n * Implementation of Writable\n *\n * @override\n * @private\n */\nBatch.prototype._write = function(record, enc, cb) {\n  record = _.clone(record);\n  if (this.job.operation === \"insert\") {\n    delete record.Id;\n  } else if (this.job.operation === \"delete\") {\n    record = { Id: record.Id };\n  }\n  delete record.type;\n  delete record.attributes;\n  this._uploadStream.write(record, enc, cb);\n};\n\n/**\n * Returns duplex stream which accepts CSV data input and batch result output\n *\n * @returns {stream.Duplex}\n */\nBatch.prototype.stream = function() {\n  return this._dataStream;\n};\n\n/**\n * Execute batch operation\n *\n * @method Bulk~Batch#execute\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for batch operation. Accepts array of records, CSV string, and CSV data input stream in insert/update/upsert/delete/hardDelete operation, SOQL string in query operation.\n * @param {Callback.<Array.<RecordResult>|Array.<BatchResultInfo>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nBatch.prototype.run =\nBatch.prototype.exec =\nBatch.prototype.execute = function(input, callback) {\n  var self = this;\n\n  if (typeof input === 'function') { // if input argument is omitted\n    callback = input;\n    input = null;\n  }\n\n  // if batch is already executed\n  if (this._result) {\n    throw new Error(\"Batch already executed.\");\n  }\n\n  var rdeferred = Promise.defer();\n  this._result = rdeferred.promise;\n  this._result.then(function(res) {\n    self._deferred.resolve(res);\n  }, function(err) {\n    self._deferred.reject(err);\n  });\n  this.once('response', function(res) {\n    rdeferred.resolve(res);\n  });\n  this.once('error', function(err) {\n    rdeferred.reject(err);\n  });\n\n  if (_.isObject(input) && _.isFunction(input.pipe)) { // if input has stream.Readable interface\n    input.pipe(this._dataStream);\n  } else {\n    var data;\n    if (_.isArray(input)) {\n      _.forEach(input, function(record) { self.write(record); });\n      self.end();\n    } else if (_.isString(input)){\n      data = input;\n      this._dataStream.write(data, 'utf8');\n      this._dataStream.end();\n    }\n  }\n\n  // return Batch instance for chaining\n  return this.thenCall(callback);\n};\n\n/**\n * Promise/A+ interface\n * http://promises-aplus.github.io/promises-spec/\n *\n * Delegate to deferred promise, return promise instance for batch result\n *\n * @method Bulk~Batch#then\n */\nBatch.prototype.then = function(onResolved, onReject, onProgress) {\n  return this._deferred.promise.then(onResolved, onReject, onProgress);\n};\n\n/**\n * Promise/A+ extension\n * Call \"then\" using given node-style callback function\n *\n * @method Bulk~Batch#thenCall\n */\nBatch.prototype.thenCall = function(callback) {\n  if (_.isFunction(callback)) {\n    this.then(function(res) {\n      process.nextTick(function() {\n        callback(null, res);\n      });\n    }, function(err) {\n      process.nextTick(function() {\n        callback(err);\n      });\n    });\n  }\n  return this;\n};\n\n/**\n * @typedef {Object} Bulk~BatchInfo\n * @prop {String} id - Batch ID\n * @prop {String} jobId - Job ID\n * @prop {String} state - Batch state\n * @prop {String} stateMessage - Batch state message\n */\n\n/**\n * Check the latest batch status in server\n *\n * @method Bulk~Batch#check\n * @param {Callback.<Bulk~BatchInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~BatchInfo>}\n */\nBatch.prototype.check = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n  var jobId = this.job.id;\n  var batchId = this.id;\n\n  if (!jobId || !batchId) {\n    throw new Error(\"Batch not started.\");\n  }\n  return bulk._request({\n    method : 'GET',\n    path : \"/job/\" + jobId + \"/batch/\" + batchId,\n    responseType: \"application/xml\"\n  }).then(function(res) {\n    logger.debug(res.batchInfo);\n    return res.batchInfo;\n  }).thenCall(callback);\n};\n\n\n/**\n * Polling the batch result and retrieve\n *\n * @method Bulk~Batch#poll\n * @param {Number} interval - Polling interval in milliseconds\n * @param {Number} timeout - Polling timeout in milliseconds\n */\nBatch.prototype.poll = function(interval, timeout) {\n  var self = this;\n  var jobId = this.job.id;\n  var batchId = this.id;\n\n  if (!jobId || !batchId) {\n    throw new Error(\"Batch not started.\");\n  }\n  var startTime = new Date().getTime();\n  var poll = function() {\n    var now = new Date().getTime();\n    if (startTime + timeout < now) {\n      var err = new Error(\"Polling time out. Job Id = \" + jobId + \" , batch Id = \" + batchId);\n      err.name = 'PollingTimeout';\n      self.emit('error', err);\n      return;\n    }\n    self.check(function(err, res) {\n      if (err) {\n        self.emit('error', err);\n      } else {\n        if (res.state === \"Failed\") {\n          if (parseInt(res.numberRecordsProcessed, 10) > 0) {\n            self.retrieve();\n          } else {\n            self.emit('error', new Error(res.stateMessage));\n          }\n        } else if (res.state === \"Completed\") {\n          self.retrieve();\n        } else {\n          self.emit('progress', res);\n          setTimeout(poll, interval);\n        }\n      }\n    });\n  };\n  setTimeout(poll, interval);\n};\n\n/**\n * @typedef {Object} Bulk~BatchResultInfo\n * @prop {String} id - Batch result ID\n * @prop {String} batchId - Batch ID which includes this batch result.\n * @prop {String} jobId - Job ID which includes this batch result.\n */\n\n/**\n * Retrieve batch result\n *\n * @method Bulk~Batch#retrieve\n * @param {Callback.<Array.<RecordResult>|Array.<Bulk~BatchResultInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>|Array.<Bulk~BatchResultInfo>>}\n */\nBatch.prototype.retrieve = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var jobId = this.job.id;\n  var job = this.job;\n  var batchId = this.id;\n\n  if (!jobId || !batchId) {\n    throw new Error(\"Batch not started.\");\n  }\n\n  return job.info().then(function(jobInfo) {\n    return bulk._request({\n      method : 'GET',\n      path : \"/job/\" + jobId + \"/batch/\" + batchId + \"/result\"\n    });\n  }).then(function(res) {\n    var results;\n    if (job.operation === 'query') {\n      var conn = bulk._conn;\n      var resultIds = res['result-list'].result;\n      results = res['result-list'].result;\n      results = _.map(_.isArray(results) ? results : [ results ], function(id) {\n        return {\n          id: id,\n          batchId: batchId,\n          jobId: jobId\n        };\n      });\n    } else {\n      results = _.map(res, function(ret) {\n        return {\n          id: ret.Id || null,\n          success: ret.Success === \"true\",\n          errors: ret.Error ? [ ret.Error ] : []\n        };\n      });\n    }\n    self.emit('response', results);\n    return results;\n  }).fail(function(err) {\n    self.emit('error', err);\n    throw err;\n  }).thenCall(callback);\n};\n\n/**\n * Fetch query result as a record stream\n * @param {String} resultId - Result id\n * @returns {RecordStream} - Record stream, convertible to CSV data stream\n */\nBatch.prototype.result = function(resultId) {\n  var jobId = this.job.id;\n  var batchId = this.id;\n  if (!jobId || !batchId) {\n    throw new Error(\"Batch not started.\");\n  }\n  var resultStream = new RecordStream.Parsable();\n  var resultDataStream = resultStream.stream('csv');\n  var reqStream = this._bulk._request({\n    method : 'GET',\n    path : \"/job/\" + jobId + \"/batch/\" + batchId + \"/result/\" + resultId,\n    responseType: \"application/octet-stream\"\n  }).stream().pipe(resultDataStream);\n  return resultStream;\n};\n\n/*--------------------------------------------*/\n/**\n * @private\n */\nvar BulkApi = function() {\n  BulkApi.super_.apply(this, arguments);\n};\n\ninherits(BulkApi, HttpApi);\n\nBulkApi.prototype.beforeSend = function(request) {\n  request.headers = request.headers || {};\n  request.headers[\"X-SFDC-SESSION\"] = this._conn.accessToken;\n};\n\nBulkApi.prototype.isSessionExpired = function(response) {\n  return response.statusCode === 400 &&\n    /<exceptionCode>InvalidSessionId<\\/exceptionCode>/.test(response.body);\n};\n\nBulkApi.prototype.hasErrorInResponseBody = function(body) {\n  return !!body.error;\n};\n\nBulkApi.prototype.parseError = function(body) {\n  return {\n    errorCode: body.error.exceptionCode,\n    message: body.error.exceptionMessage\n  };\n};\n\n/*--------------------------------------------*/\n\n/**\n * Class for Bulk API\n *\n * @class\n * @param {Connection} conn - Connection object\n */\nvar Bulk = function(conn) {\n  this._conn = conn;\n  this._logger = conn._logger;\n};\n\n/**\n * Polling interval in milliseconds\n * @type {Number}\n */\nBulk.prototype.pollInterval = 1000;\n\n/**\n * Polling timeout in milliseconds\n * @type {Number}\n */\nBulk.prototype.pollTimeout = 10000;\n\n/** @private **/\nBulk.prototype._request = function(request, callback) {\n  var conn = this._conn;\n  request = _.clone(request);\n  var baseUrl = [ conn.instanceUrl, \"services/async\", conn.version ].join('/');\n  request.url = baseUrl + request.path;\n  var options = { responseType: request.responseType };\n  delete request.path;\n  delete request.responseType;\n  return new BulkApi(this._conn, options).request(request).thenCall(callback);\n};\n\n/**\n * Create and start bulkload job and batch\n *\n * @param {String} type - SObject type\n * @param {String} operation - Bulk load operation ('insert', 'update', 'upsert', 'delete', or 'hardDelete')\n * @param {Object} [options] - Options for bulk loading operation\n * @param {String} [options.extIdField] - External ID field name (used when upsert operation).\n * @param {String} [options.concurrencyMode] - 'Serial' or 'Parallel'. Defaults to Parallel.\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulkload. Accepts array of records, CSV string, and CSV data input stream in insert/update/upsert/delete/hardDelete operation, SOQL string in query operation.\n * @param {Callback.<Array.<RecordResult>|Array.<Bulk~BatchResultInfo>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nBulk.prototype.load = function(type, operation, options, input, callback) {\n  var self = this;\n  if (!type || !operation) {\n    throw new Error(\"Insufficient arguments. At least, 'type' and 'operation' are required.\");\n  }\n  if (!_.isObject(options) || options.constructor !== Object) { // when options is not plain hash object, it is omitted\n    callback = input;\n    input = options;\n    options = null;\n  }\n  var job = this.createJob(type, operation, options);\n  job.once('error', function (error) {\n    if (batch) {\n      batch.emit('error', error); // pass job error to batch\n    }\n  });\n  var batch = job.createBatch();\n  var cleanup = function() {\n    batch = null;\n    job.close();\n  };\n  var cleanupOnError = function(err) {\n    if (err.name !== 'PollingTimeout') {\n      cleanup();\n    }\n  };\n  batch.on('response', cleanup);\n  batch.on('error', cleanupOnError);\n  batch.on('queue', function() { batch.poll(self.pollInterval, self.pollTimeout); });\n  return batch.execute(input, callback);\n};\n\n/**\n * Execute bulk query and get record stream\n *\n * @param {String} soql - SOQL to execute in bulk job\n * @returns {RecordStream.Parsable} - Record stream, convertible to CSV data stream\n */\nBulk.prototype.query = function(soql) {\n  var m = soql.replace(/\\([\\s\\S]+\\)/g, '').match(/FROM\\s+(\\w+)/i);\n  if (!m) {\n    throw new Error(\"No sobject type found in query, maybe caused by invalid SOQL.\");\n  }\n  var type = m[1];\n  var self = this;\n  var recordStream = new RecordStream.Parsable();\n  var dataStream = recordStream.stream('csv');\n  this.load(type, \"query\", soql).then(function(results) {\n    var streams = results.map(function(result) {\n      return self\n        .job(result.jobId)\n        .batch(result.batchId)\n        .result(result.id)\n        .stream();\n    });\n\n    joinStreams(streams).pipe(dataStream);\n  }).fail(function(err) {\n    recordStream.emit('error', err);\n  });\n  return recordStream;\n};\n\n\n/**\n * Create a new job instance\n *\n * @param {String} type - SObject type\n * @param {String} operation - Bulk load operation ('insert', 'update', 'upsert', 'delete', 'hardDelete', or 'query')\n * @param {Object} [options] - Options for bulk loading operation\n * @returns {Bulk~Job}\n */\nBulk.prototype.createJob = function(type, operation, options) {\n  return new Job(this, type, operation, options);\n};\n\n/**\n * Get a job instance specified by given job ID\n *\n * @param {String} jobId - Job ID\n * @returns {Bulk~Job}\n */\nBulk.prototype.job = function(jobId) {\n  return new Job(this, null, null, null, jobId);\n};\n\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.bulk = new Bulk(conn);\n});\n\n\nmodule.exports = Bulk;\n\n}).call(this,require('_process'))\n\n},{\"_process\":2}],2:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\n(function () {\n  try {\n    cachedSetTimeout = setTimeout;\n  } catch (e) {\n    cachedSetTimeout = function () {\n      throw new Error('setTimeout is not defined');\n    }\n  }\n  try {\n    cachedClearTimeout = clearTimeout;\n  } catch (e) {\n    cachedClearTimeout = function () {\n      throw new Error('clearTimeout is not defined');\n    }\n  }\n} ())\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = cachedSetTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    cachedClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        cachedSetTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}]},{},[1])(1)\n});\n\n","/*global process*/\n/**\n * @file Manages Salesforce Bulk API related operations\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n'use strict';\n\nvar inherits     = window.jsforce.require('inherits'),\n    stream       = window.jsforce.require('readable-stream'),\n    Duplex       = stream.Duplex,\n    events       = window.jsforce.require('events'),\n    _            = window.jsforce.require('lodash/core'),\n    joinStreams  = window.jsforce.require('multistream'),\n    jsforce      = window.jsforce.require('./core'),\n    RecordStream = window.jsforce.require('./record-stream'),\n    Promise      = window.jsforce.require('./promise'),\n    HttpApi      = window.jsforce.require('./http-api');\n\n/*--------------------------------------------*/\n\n/**\n * Class for Bulk API Job\n *\n * @protected\n * @class Bulk~Job\n * @extends events.EventEmitter\n *\n * @param {Bulk} bulk - Bulk API object\n * @param {String} [type] - SObject type\n * @param {String} [operation] - Bulk load operation ('insert', 'update', 'upsert', 'delete', or 'hardDelete')\n * @param {Object} [options] - Options for bulk loading operation\n * @param {String} [options.extIdField] - External ID field name (used when upsert operation).\n * @param {String} [options.concurrencyMode] - 'Serial' or 'Parallel'. Defaults to Parallel.\n * @param {String} [jobId] - Job ID (if already available)\n */\nvar Job = function(bulk, type, operation, options, jobId) {\n  this._bulk = bulk;\n  this.type = type;\n  this.operation = operation;\n  this.options = options || {};\n  this.id = jobId;\n  this.state = this.id ? 'Open' : 'Unknown';\n  this._batches = {};\n};\n\ninherits(Job, events.EventEmitter);\n\n/**\n * @typedef {Object} Bulk~JobInfo\n * @prop {String} id - Job ID\n * @prop {String} object - Object type name\n * @prop {String} operation - Operation type of the job\n * @prop {String} state - Job status\n */\n\n/**\n * Return latest jobInfo from cache\n *\n * @method Bulk~Job#open\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.info = function(callback) {\n  var self = this;\n  // if cache is not available, check the latest\n  if (!this._jobInfo) {\n    this._jobInfo = this.check();\n  }\n  return this._jobInfo.thenCall(callback);\n};\n\n/**\n * Open new job and get jobinfo\n *\n * @method Bulk~Job#open\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.open = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n\n  // if not requested opening job\n  if (!this._jobInfo) {\n    var operation = this.operation.toLowerCase();\n    if (operation === 'harddelete') { operation = 'hardDelete'; }\n    var body = [\n      '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\n      '<jobInfo  xmlns=\"http://www.force.com/2009/06/asyncapi/dataload\">',\n        '<operation>' + operation + '</operation>',\n        '<object>' + this.type + '</object>',\n        (this.options.extIdField ?\n         '<externalIdFieldName>'+this.options.extIdField+'</externalIdFieldName>' :\n         ''),\n        (this.options.concurrencyMode ?\n         '<concurrencyMode>'+this.options.concurrencyMode+'</concurrencyMode>' :\n         ''),\n        (this.options.assignmentRuleId ?\n          '<assignmentRuleId>' + this.options.assignmentRuleId + '</assignmentRuleId>' :\n          ''),\n        '<contentType>CSV</contentType>',\n      '</jobInfo>'\n    ].join('');\n\n    this._jobInfo = bulk._request({\n      method : 'POST',\n      path : \"/job\",\n      body : body,\n      headers : {\n        \"Content-Type\" : \"application/xml; charset=utf-8\"\n      },\n      responseType: \"application/xml\"\n    }).then(function(res) {\n      self.emit(\"open\", res.jobInfo);\n      self.id = res.jobInfo.id;\n      self.state = res.jobInfo.state;\n      return res.jobInfo;\n    }, function(err) {\n      self.emit(\"error\", err);\n      throw err;\n    });\n  }\n  return this._jobInfo.thenCall(callback);\n};\n\n/**\n * Create a new batch instance in the job\n *\n * @method Bulk~Job#createBatch\n * @returns {Bulk~Batch}\n */\nJob.prototype.createBatch = function() {\n  var batch = new Batch(this);\n  var self = this;\n  batch.on('queue', function() {\n    self._batches[batch.id] = batch;\n  });\n  return batch;\n};\n\n/**\n * Get a batch instance specified by given batch ID\n *\n * @method Bulk~Job#batch\n * @param {String} batchId - Batch ID\n * @returns {Bulk~Batch}\n */\nJob.prototype.batch = function(batchId) {\n  var batch = this._batches[batchId];\n  if (!batch) {\n    batch = new Batch(this, batchId);\n    this._batches[batchId] = batch;\n  }\n  return batch;\n};\n\n/**\n * Check the latest job status from server\n *\n * @method Bulk~Job#check\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.check = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n\n  this._jobInfo = this._waitAssign().then(function() {\n    return bulk._request({\n      method : 'GET',\n      path : \"/job/\" + self.id,\n      responseType: \"application/xml\"\n    });\n  }).then(function(res) {\n    logger.debug(res.jobInfo);\n    self.id = res.jobInfo.id;\n    self.type = res.jobInfo.object;\n    self.operation = res.jobInfo.operation;\n    self.state = res.jobInfo.state;\n    return res.jobInfo;\n  });\n  return this._jobInfo.thenCall(callback);\n};\n\n/**\n * Wait till the job is assigned to server\n *\n * @method Bulk~Job#info\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype._waitAssign = function(callback) {\n  return (this.id ? Promise.resolve({ id: this.id }) : this.open()).thenCall(callback);\n};\n\n\n/**\n * List all registered batch info in job\n *\n * @method Bulk~Job#list\n * @param {Callback.<Array.<Bulk~BatchInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<Bulk~BatchInfo>>}\n */\nJob.prototype.list = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n\n  return this._waitAssign().then(function() {\n    return bulk._request({\n      method : 'GET',\n      path : \"/job/\" + self.id + \"/batch\",\n      responseType: \"application/xml\"\n    });\n  }).then(function(res) {\n    logger.debug(res.batchInfoList.batchInfo);\n    var batchInfoList = res.batchInfoList;\n    batchInfoList = _.isArray(batchInfoList.batchInfo) ? batchInfoList.batchInfo : [ batchInfoList.batchInfo ];\n    return batchInfoList;\n  }).thenCall(callback);\n\n};\n\n/**\n * Close opened job\n *\n * @method Bulk~Job#close\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.close = function() {\n  var self = this;\n  return this._changeState(\"Closed\").then(function(jobInfo) {\n    self.id = null;\n    self.emit(\"close\", jobInfo);\n    return jobInfo;\n  }, function(err) {\n    self.emit(\"error\", err);\n    throw err;\n  });\n};\n\n/**\n * Set the status to abort\n *\n * @method Bulk~Job#abort\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.abort = function() {\n  var self = this;\n  return this._changeState(\"Aborted\").then(function(jobInfo) {\n    self.id = null;\n    self.emit(\"abort\", jobInfo);\n    return jobInfo;\n  }, function(err) {\n    self.emit(\"error\", err);\n    throw err;\n  });\n};\n\n/**\n * @private\n */\nJob.prototype._changeState = function(state, callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n\n  this._jobInfo = this._waitAssign().then(function() {\n    var body = [\n      '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\n      '<jobInfo xmlns=\"http://www.force.com/2009/06/asyncapi/dataload\">',\n        '<state>' + state + '</state>',\n      '</jobInfo>'\n    ].join('');\n    return bulk._request({\n      method : 'POST',\n      path : \"/job/\" + self.id,\n      body : body,\n      headers : {\n        \"Content-Type\" : \"application/xml; charset=utf-8\"\n      },\n      responseType: \"application/xml\"\n    });\n  }).then(function(res) {\n    logger.debug(res.jobInfo);\n    self.state = res.jobInfo.state;\n    return res.jobInfo;\n  });\n  return this._jobInfo.thenCall(callback);\n\n};\n\n\n/*--------------------------------------------*/\n\n/**\n * Batch (extends RecordStream)\n *\n * @protected\n * @class Bulk~Batch\n * @extends {stream.Writable}\n * @implements {Promise.<Array.<RecordResult>>}\n * @param {Bulk~Job} job - Bulk job object\n * @param {String} [batchId] - Batch ID (if already available)\n */\nvar Batch = function(job, batchId) {\n  Batch.super_.call(this, { objectMode: true });\n  this.job = job;\n  this.id = batchId;\n  this._bulk = job._bulk;\n  this._deferred = Promise.defer();\n  this._setupDataStreams();\n};\n\ninherits(Batch, stream.Writable);\n\n\n/**\n * @private\n */\nBatch.prototype._setupDataStreams = function() {\n  var batch = this;\n  var converterOptions = { nullValue : '#N/A' };\n  this._uploadStream = new RecordStream.Serializable();\n  this._uploadDataStream = this._uploadStream.stream('csv', converterOptions);\n  this._downloadStream = new RecordStream.Parsable();\n  this._downloadDataStream = this._downloadStream.stream('csv', converterOptions);\n\n  this.on('finish', function() {\n    batch._uploadStream.end();\n  });\n  this._uploadDataStream.once('readable', function() {\n    batch.job.open().then(function() {\n      // pipe upload data to batch API request stream\n      batch._uploadDataStream.pipe(batch._createRequestStream());\n    });\n  });\n\n  // duplex data stream, opened access to API programmers by Batch#stream()\n  var dataStream = this._dataStream = new Duplex();\n  dataStream._write = function(data, enc, cb) {\n    batch._uploadDataStream.write(data, enc, cb);\n  };\n  dataStream.on('finish', function() {\n    batch._uploadDataStream.end();\n  });\n\n  this._downloadDataStream.on('readable', function() {\n    dataStream.read(0);\n  });\n  this._downloadDataStream.on('end', function() {\n    dataStream.push(null);\n  });\n  dataStream._read = function(size) {\n    var chunk;\n    while ((chunk = batch._downloadDataStream.read()) !== null) {\n      dataStream.push(chunk);\n    }\n  };\n};\n\n/**\n * Connect batch API and create stream instance of request/response\n *\n * @private\n * @returns {stream.Duplex}\n */\nBatch.prototype._createRequestStream = function() {\n  var batch = this;\n  var bulk = batch._bulk;\n  var logger = bulk._logger;\n\n  return bulk._request({\n    method : 'POST',\n    path : \"/job/\" + batch.job.id + \"/batch\",\n    headers: {\n      \"Content-Type\": \"text/csv\"\n    },\n    responseType: \"application/xml\"\n  }, function(err, res) {\n    if (err) {\n      batch.emit('error', err);\n    } else {\n      logger.debug(res.batchInfo);\n      batch.id = res.batchInfo.id;\n      batch.emit('queue', res.batchInfo);\n    }\n  }).stream();\n};\n\n/**\n * Implementation of Writable\n *\n * @override\n * @private\n */\nBatch.prototype._write = function(record, enc, cb) {\n  record = _.clone(record);\n  if (this.job.operation === \"insert\") {\n    delete record.Id;\n  } else if (this.job.operation === \"delete\") {\n    record = { Id: record.Id };\n  }\n  delete record.type;\n  delete record.attributes;\n  this._uploadStream.write(record, enc, cb);\n};\n\n/**\n * Returns duplex stream which accepts CSV data input and batch result output\n *\n * @returns {stream.Duplex}\n */\nBatch.prototype.stream = function() {\n  return this._dataStream;\n};\n\n/**\n * Execute batch operation\n *\n * @method Bulk~Batch#execute\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for batch operation. Accepts array of records, CSV string, and CSV data input stream in insert/update/upsert/delete/hardDelete operation, SOQL string in query operation.\n * @param {Callback.<Array.<RecordResult>|Array.<BatchResultInfo>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nBatch.prototype.run =\nBatch.prototype.exec =\nBatch.prototype.execute = function(input, callback) {\n  var self = this;\n\n  if (typeof input === 'function') { // if input argument is omitted\n    callback = input;\n    input = null;\n  }\n\n  // if batch is already executed\n  if (this._result) {\n    throw new Error(\"Batch already executed.\");\n  }\n\n  var rdeferred = Promise.defer();\n  this._result = rdeferred.promise;\n  this._result.then(function(res) {\n    self._deferred.resolve(res);\n  }, function(err) {\n    self._deferred.reject(err);\n  });\n  this.once('response', function(res) {\n    rdeferred.resolve(res);\n  });\n  this.once('error', function(err) {\n    rdeferred.reject(err);\n  });\n\n  if (_.isObject(input) && _.isFunction(input.pipe)) { // if input has stream.Readable interface\n    input.pipe(this._dataStream);\n  } else {\n    var data;\n    if (_.isArray(input)) {\n      _.forEach(input, function(record) { self.write(record); });\n      self.end();\n    } else if (_.isString(input)){\n      data = input;\n      this._dataStream.write(data, 'utf8');\n      this._dataStream.end();\n    }\n  }\n\n  // return Batch instance for chaining\n  return this.thenCall(callback);\n};\n\n/**\n * Promise/A+ interface\n * http://promises-aplus.github.io/promises-spec/\n *\n * Delegate to deferred promise, return promise instance for batch result\n *\n * @method Bulk~Batch#then\n */\nBatch.prototype.then = function(onResolved, onReject, onProgress) {\n  return this._deferred.promise.then(onResolved, onReject, onProgress);\n};\n\n/**\n * Promise/A+ extension\n * Call \"then\" using given node-style callback function\n *\n * @method Bulk~Batch#thenCall\n */\nBatch.prototype.thenCall = function(callback) {\n  if (_.isFunction(callback)) {\n    this.then(function(res) {\n      process.nextTick(function() {\n        callback(null, res);\n      });\n    }, function(err) {\n      process.nextTick(function() {\n        callback(err);\n      });\n    });\n  }\n  return this;\n};\n\n/**\n * @typedef {Object} Bulk~BatchInfo\n * @prop {String} id - Batch ID\n * @prop {String} jobId - Job ID\n * @prop {String} state - Batch state\n * @prop {String} stateMessage - Batch state message\n */\n\n/**\n * Check the latest batch status in server\n *\n * @method Bulk~Batch#check\n * @param {Callback.<Bulk~BatchInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~BatchInfo>}\n */\nBatch.prototype.check = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n  var jobId = this.job.id;\n  var batchId = this.id;\n\n  if (!jobId || !batchId) {\n    throw new Error(\"Batch not started.\");\n  }\n  return bulk._request({\n    method : 'GET',\n    path : \"/job/\" + jobId + \"/batch/\" + batchId,\n    responseType: \"application/xml\"\n  }).then(function(res) {\n    logger.debug(res.batchInfo);\n    return res.batchInfo;\n  }).thenCall(callback);\n};\n\n\n/**\n * Polling the batch result and retrieve\n *\n * @method Bulk~Batch#poll\n * @param {Number} interval - Polling interval in milliseconds\n * @param {Number} timeout - Polling timeout in milliseconds\n */\nBatch.prototype.poll = function(interval, timeout) {\n  var self = this;\n  var jobId = this.job.id;\n  var batchId = this.id;\n\n  if (!jobId || !batchId) {\n    throw new Error(\"Batch not started.\");\n  }\n  var startTime = new Date().getTime();\n  var poll = function() {\n    var now = new Date().getTime();\n    if (startTime + timeout < now) {\n      var err = new Error(\"Polling time out. Job Id = \" + jobId + \" , batch Id = \" + batchId);\n      err.name = 'PollingTimeout';\n      self.emit('error', err);\n      return;\n    }\n    self.check(function(err, res) {\n      if (err) {\n        self.emit('error', err);\n      } else {\n        if (res.state === \"Failed\") {\n          if (parseInt(res.numberRecordsProcessed, 10) > 0) {\n            self.retrieve();\n          } else {\n            self.emit('error', new Error(res.stateMessage));\n          }\n        } else if (res.state === \"Completed\") {\n          self.retrieve();\n        } else {\n          self.emit('progress', res);\n          setTimeout(poll, interval);\n        }\n      }\n    });\n  };\n  setTimeout(poll, interval);\n};\n\n/**\n * @typedef {Object} Bulk~BatchResultInfo\n * @prop {String} id - Batch result ID\n * @prop {String} batchId - Batch ID which includes this batch result.\n * @prop {String} jobId - Job ID which includes this batch result.\n */\n\n/**\n * Retrieve batch result\n *\n * @method Bulk~Batch#retrieve\n * @param {Callback.<Array.<RecordResult>|Array.<Bulk~BatchResultInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>|Array.<Bulk~BatchResultInfo>>}\n */\nBatch.prototype.retrieve = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var jobId = this.job.id;\n  var job = this.job;\n  var batchId = this.id;\n\n  if (!jobId || !batchId) {\n    throw new Error(\"Batch not started.\");\n  }\n\n  return job.info().then(function(jobInfo) {\n    return bulk._request({\n      method : 'GET',\n      path : \"/job/\" + jobId + \"/batch/\" + batchId + \"/result\"\n    });\n  }).then(function(res) {\n    var results;\n    if (job.operation === 'query') {\n      var conn = bulk._conn;\n      var resultIds = res['result-list'].result;\n      results = res['result-list'].result;\n      results = _.map(_.isArray(results) ? results : [ results ], function(id) {\n        return {\n          id: id,\n          batchId: batchId,\n          jobId: jobId\n        };\n      });\n    } else {\n      results = _.map(res, function(ret) {\n        return {\n          id: ret.Id || null,\n          success: ret.Success === \"true\",\n          errors: ret.Error ? [ ret.Error ] : []\n        };\n      });\n    }\n    self.emit('response', results);\n    return results;\n  }).fail(function(err) {\n    self.emit('error', err);\n    throw err;\n  }).thenCall(callback);\n};\n\n/**\n * Fetch query result as a record stream\n * @param {String} resultId - Result id\n * @returns {RecordStream} - Record stream, convertible to CSV data stream\n */\nBatch.prototype.result = function(resultId) {\n  var jobId = this.job.id;\n  var batchId = this.id;\n  if (!jobId || !batchId) {\n    throw new Error(\"Batch not started.\");\n  }\n  var resultStream = new RecordStream.Parsable();\n  var resultDataStream = resultStream.stream('csv');\n  var reqStream = this._bulk._request({\n    method : 'GET',\n    path : \"/job/\" + jobId + \"/batch/\" + batchId + \"/result/\" + resultId,\n    responseType: \"application/octet-stream\"\n  }).stream().pipe(resultDataStream);\n  return resultStream;\n};\n\n/*--------------------------------------------*/\n/**\n * @private\n */\nvar BulkApi = function() {\n  BulkApi.super_.apply(this, arguments);\n};\n\ninherits(BulkApi, HttpApi);\n\nBulkApi.prototype.beforeSend = function(request) {\n  request.headers = request.headers || {};\n  request.headers[\"X-SFDC-SESSION\"] = this._conn.accessToken;\n};\n\nBulkApi.prototype.isSessionExpired = function(response) {\n  return response.statusCode === 400 &&\n    /<exceptionCode>InvalidSessionId<\\/exceptionCode>/.test(response.body);\n};\n\nBulkApi.prototype.hasErrorInResponseBody = function(body) {\n  return !!body.error;\n};\n\nBulkApi.prototype.parseError = function(body) {\n  return {\n    errorCode: body.error.exceptionCode,\n    message: body.error.exceptionMessage\n  };\n};\n\n/*--------------------------------------------*/\n\n/**\n * Class for Bulk API\n *\n * @class\n * @param {Connection} conn - Connection object\n */\nvar Bulk = function(conn) {\n  this._conn = conn;\n  this._logger = conn._logger;\n};\n\n/**\n * Polling interval in milliseconds\n * @type {Number}\n */\nBulk.prototype.pollInterval = 1000;\n\n/**\n * Polling timeout in milliseconds\n * @type {Number}\n */\nBulk.prototype.pollTimeout = 10000;\n\n/** @private **/\nBulk.prototype._request = function(request, callback) {\n  var conn = this._conn;\n  request = _.clone(request);\n  var baseUrl = [ conn.instanceUrl, \"services/async\", conn.version ].join('/');\n  request.url = baseUrl + request.path;\n  var options = { responseType: request.responseType };\n  delete request.path;\n  delete request.responseType;\n  return new BulkApi(this._conn, options).request(request).thenCall(callback);\n};\n\n/**\n * Create and start bulkload job and batch\n *\n * @param {String} type - SObject type\n * @param {String} operation - Bulk load operation ('insert', 'update', 'upsert', 'delete', or 'hardDelete')\n * @param {Object} [options] - Options for bulk loading operation\n * @param {String} [options.extIdField] - External ID field name (used when upsert operation).\n * @param {String} [options.concurrencyMode] - 'Serial' or 'Parallel'. Defaults to Parallel.\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulkload. Accepts array of records, CSV string, and CSV data input stream in insert/update/upsert/delete/hardDelete operation, SOQL string in query operation.\n * @param {Callback.<Array.<RecordResult>|Array.<Bulk~BatchResultInfo>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nBulk.prototype.load = function(type, operation, options, input, callback) {\n  var self = this;\n  if (!type || !operation) {\n    throw new Error(\"Insufficient arguments. At least, 'type' and 'operation' are required.\");\n  }\n  if (!_.isObject(options) || options.constructor !== Object) { // when options is not plain hash object, it is omitted\n    callback = input;\n    input = options;\n    options = null;\n  }\n  var job = this.createJob(type, operation, options);\n  job.once('error', function (error) {\n    if (batch) {\n      batch.emit('error', error); // pass job error to batch\n    }\n  });\n  var batch = job.createBatch();\n  var cleanup = function() {\n    batch = null;\n    job.close();\n  };\n  var cleanupOnError = function(err) {\n    if (err.name !== 'PollingTimeout') {\n      cleanup();\n    }\n  };\n  batch.on('response', cleanup);\n  batch.on('error', cleanupOnError);\n  batch.on('queue', function() { batch.poll(self.pollInterval, self.pollTimeout); });\n  return batch.execute(input, callback);\n};\n\n/**\n * Execute bulk query and get record stream\n *\n * @param {String} soql - SOQL to execute in bulk job\n * @returns {RecordStream.Parsable} - Record stream, convertible to CSV data stream\n */\nBulk.prototype.query = function(soql) {\n  var m = soql.replace(/\\([\\s\\S]+\\)/g, '').match(/FROM\\s+(\\w+)/i);\n  if (!m) {\n    throw new Error(\"No sobject type found in query, maybe caused by invalid SOQL.\");\n  }\n  var type = m[1];\n  var self = this;\n  var recordStream = new RecordStream.Parsable();\n  var dataStream = recordStream.stream('csv');\n  this.load(type, \"query\", soql).then(function(results) {\n    var streams = results.map(function(result) {\n      return self\n        .job(result.jobId)\n        .batch(result.batchId)\n        .result(result.id)\n        .stream();\n    });\n\n    joinStreams(streams).pipe(dataStream);\n  }).fail(function(err) {\n    recordStream.emit('error', err);\n  });\n  return recordStream;\n};\n\n\n/**\n * Create a new job instance\n *\n * @param {String} type - SObject type\n * @param {String} operation - Bulk load operation ('insert', 'update', 'upsert', 'delete', 'hardDelete', or 'query')\n * @param {Object} [options] - Options for bulk loading operation\n * @returns {Bulk~Job}\n */\nBulk.prototype.createJob = function(type, operation, options) {\n  return new Job(this, type, operation, options);\n};\n\n/**\n * Get a job instance specified by given job ID\n *\n * @param {String} jobId - Job ID\n * @returns {Bulk~Job}\n */\nBulk.prototype.job = function(jobId) {\n  return new Job(this, null, null, null, jobId);\n};\n\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.bulk = new Bulk(conn);\n});\n\n\nmodule.exports = Bulk;\n","// shim for using process in browser\n\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\n(function () {\n  try {\n    cachedSetTimeout = setTimeout;\n  } catch (e) {\n    cachedSetTimeout = function () {\n      throw new Error('setTimeout is not defined');\n    }\n  }\n  try {\n    cachedClearTimeout = clearTimeout;\n  } catch (e) {\n    cachedClearTimeout = function () {\n      throw new Error('clearTimeout is not defined');\n    }\n  }\n} ())\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = cachedSetTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    cachedClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        cachedSetTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"],"sourceRoot":"/source/"}